'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       MIT License http://www.opensource.org/licenses/mit-license.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Author Tobias Koppers @sokra
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _sourceMap = require('source-map');

var _webpackSources = require('webpack-sources');

var _RequestShortener = require('webpack/lib/RequestShortener');

var _RequestShortener2 = _interopRequireDefault(_RequestShortener);

var _ModuleFilenameHelpers = require('webpack/lib/ModuleFilenameHelpers');

var _ModuleFilenameHelpers2 = _interopRequireDefault(_ModuleFilenameHelpers);

var _uglifyEs = require('uglify-es');

var _uglifyEs2 = _interopRequireDefault(_uglifyEs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable
  no-param-reassign
*/

var warningRegex = /\[.+:([0-9]+),([0-9]+)\]/;

var defaultUglifyOptions = {
  output: {
    comments: /^\**!|@preserve|@license|@cc_on/,
    beautify: false,
    semicolons: true,
    shebang: true
  }
};

var UglifyJsPlugin = function () {
  function UglifyJsPlugin(options) {
    _classCallCheck(this, UglifyJsPlugin);

    if (typeof options !== 'object' || Array.isArray(options)) {
      this.options = {};
    } else {
      this.options = options || {};
    }

    this.options.test = this.options.test || /\.js($|\?)/i;
    this.options.warningsFilter = this.options.warningsFilter || function () {
      return true;
    };

    this.uglifyOptions = this.options.uglifyOptions || {};
  }

  _createClass(UglifyJsPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      var requestShortener = new _RequestShortener2.default(compiler.context);
      // Copy uglify options
      var uglifyOptions = UglifyJsPlugin.buildDefaultUglifyOptions(this.uglifyOptions);
      // Making sure output options exists if there is an extractComments options
      if (this.options.extractComments) {
        uglifyOptions.output = uglifyOptions.output || {};
      }

      compiler.plugin('compilation', function (compilation) {
        if (_this.options.sourceMap) {
          compilation.plugin('build-module', function (moduleArg) {
            // to get detailed location info about errors
            moduleArg.useSourceMap = true;
          });
        }

        compilation.plugin('optimize-chunk-assets', function (chunks, callback) {
          var uglifiedAssets = new WeakSet();
          chunks.reduce(function (acc, chunk) {
            return acc.concat(chunk.files || []);
          }, []).concat(compilation.additionalChunkAssets || []).filter(_ModuleFilenameHelpers2.default.matchObject.bind(null, _this.options)).forEach(function (file) {
            // Reseting sourcemap to null
            uglifyOptions.sourceMap = null;
            var sourceMap = void 0;
            var asset = compilation.assets[file];
            if (uglifiedAssets.has(asset)) {
              return;
            }

            try {
              var input = void 0;
              var inputSourceMap = void 0;
              if (_this.options.sourceMap) {
                if (asset.sourceAndMap) {
                  var sourceAndMap = asset.sourceAndMap();
                  inputSourceMap = sourceAndMap.map;
                  input = sourceAndMap.source;
                } else {
                  inputSourceMap = asset.map();
                  input = asset.source();
                }
                sourceMap = new _sourceMap.SourceMapConsumer(inputSourceMap);
                // Add source map data
                uglifyOptions.sourceMap = {
                  content: inputSourceMap
                };
              } else {
                input = asset.source();
              }

              // Handling comment extraction
              var extractedComments = [];
              var commentsFile = false;
              if (_this.options.extractComments) {
                uglifyOptions.output.comments = UglifyJsPlugin.buildCommentsFunction(_this.options, uglifyOptions, extractedComments);

                commentsFile = _this.options.extractComments.filename || `${file}.LICENSE`;
                if (typeof commentsFile === 'function') {
                  commentsFile = commentsFile(file);
                }
              }

              // Calling uglify

              var _uglify$minify = _uglifyEs2.default.minify({ [file]: input }, uglifyOptions),
                  error = _uglify$minify.error,
                  map = _uglify$minify.map,
                  code = _uglify$minify.code,
                  warnings = _uglify$minify.warnings;

              // Handling results
              // Error case: add errors, and go to next file


              if (error) {
                compilation.errors.push(UglifyJsPlugin.buildError(error, file, sourceMap, compilation, requestShortener));
                return;
              }

              var outputSource = void 0;
              if (map) {
                outputSource = new _webpackSources.SourceMapSource(code, file, JSON.parse(map), input, inputSourceMap);
              } else {
                outputSource = new _webpackSources.RawSource(code);
              }

              // Write extracted comments to commentsFile
              if (commentsFile && extractedComments.length > 0) {
                // Add a banner to the original file
                if (_this.options.extractComments.banner !== false) {
                  var banner = _this.options.extractComments.banner || `For license information please see ${commentsFile}`;
                  if (typeof banner === 'function') {
                    banner = banner(commentsFile);
                  }
                  if (banner) {
                    outputSource = new _webpackSources.ConcatSource(`/*! ${banner} */\n`, outputSource);
                  }
                }

                var commentsSource = new _webpackSources.RawSource(`${extractedComments.join('\n\n')}\n`);
                if (commentsFile in compilation.assets) {
                  // commentsFile already exists, append new comments...
                  if (compilation.assets[commentsFile] instanceof _webpackSources.ConcatSource) {
                    compilation.assets[commentsFile].add('\n');
                    compilation.assets[commentsFile].add(commentsSource);
                  } else {
                    compilation.assets[commentsFile] = new _webpackSources.ConcatSource(compilation.assets[commentsFile], '\n', commentsSource);
                  }
                } else {
                  compilation.assets[commentsFile] = commentsSource;
                }
              }

              // Updating assets
              uglifiedAssets.add(compilation.assets[file] = outputSource);

              // Handling warnings
              if (warnings) {
                var warnArr = UglifyJsPlugin.buildWarnings(warnings, file, sourceMap, _this.options.warningsFilter, requestShortener);
                if (warnArr.length > 0) {
                  compilation.warnings.push(new Error(`${file} from UglifyJs\n${warnArr.join('\n')}`));
                }
              }
            } catch (error) {
              compilation.errors.push(UglifyJsPlugin.buildError(error, file, sourceMap, compilation, requestShortener));
            }
          });
          callback();
        });
      });
    }
  }], [{
    key: 'buildDefaultUglifyOptions',
    value: function buildDefaultUglifyOptions(_ref) {
      var ecma = _ref.ecma,
          warnings = _ref.warnings,
          _ref$parse = _ref.parse,
          parse = _ref$parse === undefined ? {} : _ref$parse,
          _ref$compress = _ref.compress,
          compress = _ref$compress === undefined ? {} : _ref$compress,
          mangle = _ref.mangle,
          output = _ref.output,
          toplevel = _ref.toplevel,
          ie8 = _ref.ie8;

      return {
        ecma,
        warnings,
        parse,
        compress,
        mangle: mangle == null ? true : mangle,
        // Ignoring sourcemap from options
        sourceMap: null,
        output: Object.assign({}, defaultUglifyOptions.output, output),
        toplevel,
        ie8
      };
    }
  }, {
    key: 'buildError',
    value: function buildError(err, file, sourceMap, requestShortener) {
      // Handling error which should have line, col, filename and message
      if (err.line) {
        var original = sourceMap && sourceMap.originalPositionFor({
          line: err.line,
          column: err.col
        });
        if (original && original.source) {
          return new Error(`${file} from UglifyJs\n${err.message} [${requestShortener.shorten(original.source)}:${original.line},${original.column}][${file}:${err.line},${err.col}]`);
        }
        return new Error(`${file} from UglifyJs\n${err.message} [${file}:${err.line},${err.col}]`);
      } else if (err.msg) {
        return new Error(`${file} from UglifyJs\n${err.msg}`);
      }
      return new Error(`${file} from UglifyJs\n${err.stack}`);
    }
  }, {
    key: 'buildWarnings',
    value: function buildWarnings(warnings, file, sourceMap, warningsFilter, requestShortener) {
      if (!sourceMap) {
        return warnings;
      }
      return warnings.reduce(function (accWarnings, warning) {
        var match = warningRegex.exec(warning);
        var line = +match[1];
        var column = +match[2];
        var original = sourceMap.originalPositionFor({
          line,
          column
        });

        if (original && original.source && original.source !== file && warningsFilter(original.source)) {
          accWarnings.push(`${warning.replace(warningRegex, '')}[${requestShortener.shorten(original.source)}:${original.line},${original.column}]`);
        }

        return accWarnings;
      }, []);
    }
  }, {
    key: 'buildCommentsFunction',
    value: function buildCommentsFunction(options, uglifyOptions, extractedComments) {
      var condition = {};
      var commentsOpts = uglifyOptions.output.comments;
      if (typeof options.extractComments === 'string' || options.extractComments instanceof RegExp) {
        // extractComments specifies the extract condition and commentsOpts specifies the preserve condition
        condition.preserve = commentsOpts;
        condition.extract = options.extractComments;
      } else if (Object.prototype.hasOwnProperty.call(options.extractComments, 'condition')) {
        // Extract condition is given in extractComments.condition
        condition.preserve = commentsOpts;
        condition.extract = options.extractComments.condition;
      } else {
        // No extract condition is given. Extract comments that match commentsOpts instead of preserving them
        condition.preserve = false;
        condition.extract = commentsOpts;
      }

      // Ensure that both conditions are functions
      ['preserve', 'extract'].forEach(function (key) {
        var regexStr = void 0;
        var regex = void 0;
        switch (typeof condition[key]) {
          case 'boolean':
            condition[key] = condition[key] ? function () {
              return true;
            } : function () {
              return false;
            };
            break;
          case 'function':
            break;
          case 'string':
            if (condition[key] === 'all') {
              condition[key] = function () {
                return true;
              };
              break;
            }
            if (condition[key] === 'some') {
              condition[key] = function (astNode, comment) {
                return comment.type === 'comment2' && /@preserve|@license|@cc_on/i.test(comment.value);
              };
              break;
            }
            regexStr = condition[key];
            condition[key] = function (astNode, comment) {
              return new RegExp(regexStr).test(comment.value);
            };
            break;
          default:
            regex = condition[key];
            condition[key] = function (astNode, comment) {
              return regex.test(comment.value);
            };
        }
      });

      // Redefine the comments function to extract and preserve
      // comments according to the two conditions
      return function (astNode, comment) {
        if (condition.extract(astNode, comment)) {
          extractedComments.push(comment.type === 'comment2' ? `/*${comment.value}*/` : `//${comment.value}`);
        }
        return condition.preserve(astNode, comment);
      };
    }
  }]);

  return UglifyJsPlugin;
}();

exports.default = UglifyJsPlugin;