/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/external/graphAndNode.js":
/*!*************************************!*\
  !*** ./js/external/graphAndNode.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Constant\r\nfunction LGraphSmooth()\r\n{\r\n\r\n    this._ctor(LGraphSmooth.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"a\",\"\", {float:1});\r\n    this.addInput(\"b\",\"\", {float:1});\r\n    this.addInput(\"k\",\"\", {float:1});\r\n    this.properties.name = \"\";\r\n    this.options =  this.options || {};\r\n    this.properties.optType = \"min\";\r\n    this.options.optType = {multichoice:[ 'min','max'], reloadonchange:1}; \r\n    this.shader_piece = new Psmooth();\r\n}\r\n\r\n\r\nLGraphSmooth.title = \"smooth\";\r\nLGraphSmooth.desc = \"smooth\";\r\nLGraphSmooth.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSmooth.prototype.processInputCode = function(scope)\r\n{\r\nvar A = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar B = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\nvar K = this.getInputCode(2) || LiteGraph.EMPTY_CODE;\r\n \r\n    if(A && B && K){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"smooth_\"+this.id: this.properties.name,\r\n            \r\n            out_type: this.getOutputType(),\r\n            a: A.getOutputVar(),\r\n            b: B.getOutputVar(),\r\n            k: K.getOutputVar(),\r\n            optType:this.properties.optType,\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n     \r\n    output_code.merge(A);\r\n    output_code.merge(B);\r\n    output_code.merge(K);\r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSmooth.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSmooth.title , LGraphSmooth);\r\n\r\n\r\n\r\n\r\n//Constant\r\nfunction LGraphSmooth2d()\r\n{\r\n\r\n    this._ctor(LGraphSmooth2d.title);\r\n    this.addOutput(\"result\",\"\",{vec2:1});\r\n    this.addInput(\"a\",\"\", {vec2:1});\r\n    this.addInput(\"b\",\"\", {vec2:1});\r\n    this.addInput(\"k\",\"\", {float:1});\r\n    this.properties = {name:\"\"};\r\n    this.options =  this.options || {};\r\n    this.shader_piece = new Psmooth2d();\r\n}\r\n\r\n\r\nLGraphSmooth2d.title = \"smooth2d\";\r\nLGraphSmooth2d.desc = \"smooth2d\";\r\nLGraphSmooth2d.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSmooth2d.prototype.processInputCode = function(scope)\r\n{\r\nvar A = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar B = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\nvar K = this.getInputCode(2) || LiteGraph.EMPTY_CODE;\r\n \r\n    if(A && B && K){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"smooth2d_\"+this.id: this.properties.name,\r\n             \r\n            out_type: this.getOutputType(),\r\n            a: A.getOutputVar(),\r\n            b: B.getOutputVar(),\r\n            k: K.getOutputVar(),\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    \r\n    output_code.merge(A);\r\n    output_code.merge(B);\r\n    output_code.merge(K);\r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSmooth2d.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSmooth2d.title , LGraphSmooth2d);\r\n\r\n\r\n\r\n\r\nfunction LGraphSdSphere()\r\n{\r\n\r\n    this._ctor(LGraphSdSphere.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"p\",\"\", {vec3:1});\r\n    this.addInput(\"s\",\"\", {float:1});\r\n    this.properties = {name:\"\"};\r\n    this.options =  this.options || {};\r\n    this.shader_piece = new PsdSphere();\r\n}\r\n\r\n\r\nLGraphSdSphere.title = \"sdSphere\";\r\nLGraphSdSphere.desc = \"sdSphere\";\r\nLGraphSdSphere.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSdSphere.prototype.processInputCode = function(scope)\r\n{\r\nvar p = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar s = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\n \r\n \r\n    if(p&&s){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"sdSphere_\"+this.id: this.properties.name,\r\n         \r\n            out_type: this.getOutputType(),\r\n            p: p.getOutputVar(),\r\n            s: s.getOutputVar(),\r\n            \r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    \r\n    output_code.merge(p);\r\n    output_code.merge(s);\r\n    \r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSdSphere.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSdSphere.title , LGraphSdSphere);\r\n\r\n\r\n\r\n\r\nfunction LGraphSdEllipsoid()\r\n{\r\n\r\n    this._ctor(LGraphSdEllipsoid.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"p\",\"\", {vec3:1});\r\n    this.addInput(\"r\",\"\", {vec3:1});\r\n    this.properties = {name:\"\"};\r\n    this.options =  this.options || {};\r\n    this.shader_piece = new PsdEllipsoid();\r\n}\r\n\r\n\r\nLGraphSdEllipsoid.title = \"sdEllipsoid\";\r\nLGraphSdEllipsoid.desc = \"sdEllipsoid\";\r\nLGraphSdEllipsoid.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSdEllipsoid.prototype.processInputCode = function(scope)\r\n{\r\nvar p = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar r = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\n     \r\n    if(p&&r){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"sdEllipsoid_\"+this.id: this.properties.name,\r\n             \r\n            out_type: this.getOutputType(),\r\n            p: p.getOutputVar(),\r\n            r: r.getOutputVar(),\r\n            \r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n   // console.log(\"cal_output\",output_code)\r\n    output_code.merge(p);\r\n    output_code.merge(r);\r\n    \r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSdEllipsoid.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSdEllipsoid.title , LGraphSdEllipsoid);\r\n\r\n\r\n\r\n\r\n\r\nfunction LGraphPopU()\r\n{\r\n\r\n    this._ctor(LGraphPopU.title);\r\n    this.addOutput(\"result\",\"\",{vec4:1});\r\n    this.addInput(\"d1\",\"\", {vec4:1});\r\n    this.addInput(\"d2\",\"\", {vec4:1});\r\n    this.properties = {name:\"\"};\r\n    this.options =  this.options || {};\r\n    this.shader_piece = new PopU();\r\n}\r\n\r\n\r\nLGraphPopU.title = \"popU\";\r\nLGraphPopU.desc = \"popU\";\r\nLGraphPopU.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphPopU.prototype.processInputCode = function(scope)\r\n{\r\nvar d1 = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar d2 = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\n \r\n \r\n    if(d1&&d2){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"popU_\"+this.id: this.properties.name,\r\n           \r\n            out_type: this.getOutputType(),\r\n            d1: d1.getOutputVar(),\r\n            d2: d2.getOutputVar(),\r\n            \r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    \r\n    output_code.merge(d1);\r\n    output_code.merge(d2);\r\n    \r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphPopU.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphPopU.title , LGraphPopU);\r\n\r\n\r\n\r\n\r\n\r\nfunction LGraphSdStick()\r\n{\r\n\r\n    this._ctor(LGraphSdStick.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"p\",\"\", {vec3:1});\r\n    this.addInput(\"a\",\"\", {vec3:1});\r\n    this.addInput(\"b\",\"\", {vec3:1});\r\n    this.addInput(\"r1\",\"\", {float:1});\r\n    this.addInput(\"r2\",\"\", {float:1});\r\n    this.options =  this.options || {};\r\n    this.shader_piece = new PsdStick();\r\n    this.properties = {name:\"\"};\r\n}\r\n\r\n\r\nLGraphSdStick.title = \"sdStick\";\r\nLGraphSdStick.desc = \"sdStick\";\r\nLGraphSdStick.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSdStick.prototype.processInputCode = function(scope)\r\n{\r\nvar p = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar a = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\nvar b = this.getInputCode(2) || LiteGraph.EMPTY_CODE;\r\nvar r1 = this.getInputCode(3) || LiteGraph.EMPTY_CODE;\r\nvar r2 = this.getInputCode(4) || LiteGraph.EMPTY_CODE;\r\n\r\n    if(p&&a&&b&&r1&&r2){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"sdStick_\"+this.id: this.properties.name,\r\n            \r\n            out_type: this.getOutputType(),\r\n            p: p.getOutputVar(),\r\n            a: a.getOutputVar(),\r\n            b: b.getOutputVar(),\r\n            r1: r1.getOutputVar(),\r\n            r2: r2.getOutputVar(),\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    \r\n    output_code.merge(p);\r\n    output_code.merge(a);\r\n    output_code.merge(b);\r\n    output_code.merge(r1);\r\n    output_code.merge(r2);\r\n\r\n    \r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSdStick.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSdStick.title , LGraphSdStick);\r\n\r\n\r\n\r\nfunction LGraphSign()\r\n{\r\n\r\n    this._ctor(LGraphSign.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"p\",\"\", {float:1});\r\n   \r\n    this.options =  this.options || {};\r\n    this.properties = {name:\"\"};\r\n    this.shader_piece = new PsdSphere();\r\n}\r\n\r\n\r\nLGraphSign.title = \"sign\";\r\nLGraphSign.desc = \"sign\";\r\nLGraphSign.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphSign.prototype.processInputCode = function(scope)\r\n{\r\nvar p = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\n \r\n    if(p){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"sign_\"+this.id: this.properties.name,\r\n            \r\n            out_type: this.getOutputType(),\r\n            p: p.getOutputVar(),\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    output_code.merge(p);\r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphSign.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphSign.title , LGraphSign);\r\n\r\n\r\n\r\nfunction LGraphMat2()\r\n{\r\n\r\n    this._ctor(LGraphMat2.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.addInput(\"r1\",\"\", {float:1});\r\n    this.addInput(\"r2\",\"\", {float:1});\r\n    this.addInput(\"r3\",\"\", {float:1});\r\n    this.addInput(\"r4\",\"\", {float:1});\r\n    \r\n    this.options =  this.options || {};\r\n    this.properties = {name:\"\"};\r\n    this.shader_piece = new PsdSphere();\r\n}\r\n\r\nLGraphMat2.title = \"mat2\";\r\nLGraphMat2.desc = \"mat2\";\r\nLGraphMat2.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphMat2.prototype.processInputCode = function(scope)\r\n{\r\nthis.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\nvar r1 = this.getInputCode(0) || LiteGraph.EMPTY_CODE;\r\nvar r2 = this.getInputCode(1) || LiteGraph.EMPTY_CODE;\r\nvar r3 = this.getInputCode(2) || LiteGraph.EMPTY_CODE;\r\nvar r4 = this.getInputCode(3) || LiteGraph.EMPTY_CODE;\r\n\r\n    if(r1&&r2&&r3&&r4){\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    var output_code = this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:this.properties.name == \"\" ? \"mat2_\"+this.id: this.properties.name,\r\n            out_type: this.getOutputType(),\r\n            r1: r1.getOutputVar(),\r\n            r2: r2.getOutputVar(),\r\n            r3: r3.getOutputVar(),\r\n            r4: r4.getOutputVar(),\r\n            is_global:true,\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n    output_code.merge(p);\r\n    }\r\n    else {\r\n        this.codes[0] = LiteGraph.EMPTY_CODE;}\r\n     \r\n}\r\n\r\nLGraphMat2.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\n\r\nLiteGraph.registerNodeType(\"math/\"+LGraphMat2.title , LGraphMat2);\r\n\r\n\r\nfunction LGraphPos()\r\n{\r\n     \r\n    this._ctor(LGraphPos.title);\r\n    this.addOutput(\"result\",\"\",{vec3:1});\r\n    this.output_types = {vec3:1};\r\n    \r\n    this.options =  this.options || {};\r\n    this.properties = {name:\"\"};\r\n    this.shader_piece = new PPos();\r\n}\r\n\r\nLGraphPos.title = \"pos\";\r\nLGraphPos.desc = \"pos\";\r\nLGraphPos.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphPos.prototype.processInputCode = function(scope)\r\n{\r\n    this.outputs[0].name = this.properties.name == \"\" ? \"result\": this.properties.name\r\n    this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            \r\n            out_var:this.properties.name == \"\" ? \"pos_\"+this.id: this.properties.name,\r\n            out_type: this.getOutputType(),\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n \r\n}\r\n\r\nLGraphPos.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    \r\n    return string_type;\r\n}\r\nLiteGraph.registerNodeType(\"constants/\"+LGraphPos.title , LGraphPos);\r\n\r\n\r\n\r\n\r\n\r\nfunction LGraphAtime()\r\n{\r\n\r\n    this._ctor(LGraphAtime.title);\r\n    this.addOutput(\"result\",\"\",{float:1});\r\n    this.output_types = {float:1};\r\n   \r\n    this.options =  this.options || {};\r\n    this.shader_piece = new PAtime();\r\n}\r\n\r\nLGraphAtime.title = \"atime\";\r\nLGraphAtime.desc = \"atime\";\r\nLGraphAtime.prototype.onExecute = function()\r\n{\r\n    //this.processNodePath();\r\n}\r\nLGraphAtime.prototype.processInputCode = function(scope)\r\n{\r\n  \r\n    this.codes[0] = this.shader_piece.getCode(\r\n        {\r\n            out_var:\"atime_\"+this.id,\r\n            out_type: this.getOutputType(),\r\n            scope:scope,\r\n            order:this.order\r\n        });\r\n \r\n}\r\n\r\nLGraphAtime.prototype.getOutputType = function()\r\n{\r\n    var obj = this.output_types ? this.output_types :  this.T_out_types;\r\n    var string_type = LiteGraph.getOtputTypeFromMap(obj);\r\n    return string_type;\r\n}\r\nLiteGraph.registerNodeType(\"constants/\"+LGraphAtime.title , LGraphAtime);\r\n\r\n\r\n\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\n//float h = max(k-abs(a-b),0.0);\r\n//return min(a, b) - h*h*0.25/k;\r\nfunction Psmooth(){\r\n    this.id = \"smooth\";\r\n    this.includes = {};\r\n};\r\nPsmooth.prototype.getVertexCode = function (out_type,out_var,a,b,k,optType,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        \"float h =max(\"+k+\"-abs(\" +a+\"-\"+b+\"),0.0);\\n\" +\r\n        out_type+\" \" +out_var+\"=\" + optType +\"(\" +a+\",\"+b+\") -\"+\"h*h*0.25/\"+k+\";\\n\";\r\n        return code;\r\n\r\n\r\n    }\r\n};\r\nPsmooth.prototype.getFragmentCode = function (out_type,out_var,a,b,k,optType,scope){\r\n    \r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n         \r\n        out_type+\" \" +out_var+\"=smin(\"+a+\",\"+b+\",\"+k+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPsmooth.prototype.getCode = function (params) {\r\n    \r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var a = params.a;\r\n    var b = params.b;\r\n    var k = params.k;\r\n    var optType = params.optType;\r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var, a,b,k,optType, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, a,b,k,optType,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\n// vec2 smin( vec2 a, vec2 b, float k )\r\n// {\r\n//     float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\r\n//     return mix( b, a, h ) - k*h*(1.0-h);\r\n// }\r\n\r\nfunction Psmooth2d(){\r\n    this.id = \"smooth2d\";\r\n    this.includes = {};\r\n};\r\nPsmooth2d.prototype.getVertexCode = function (out_type,out_var,a,b,k,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        \"float h =clamp(0.5+0.5*(\"+b+\".x\" + \"-\" + a+\".x)/\"+k+\",0.0,1.0);\\n\" +\r\n        out_type+\" \" +out_var+\"=mix(\"+b+\",\"+a+\",h) -\"+k+\"*h*(1.0-h);\\n\";\r\n        return code;\r\n\r\n\r\n    }\r\n};\r\nPsmooth2d.prototype.getFragmentCode = function (out_type,out_var,a,b,k,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=smin2(\"+a+\",\"+b+\",\"+k+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPsmooth2d.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var a = params.a;\r\n    var b = params.b;\r\n    var k = params.k;\r\n   \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var, a,b,k, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, a,b,k,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n// float sdSphere( vec3 p, float s )\r\n// {\r\n//     return length(p)-s;\r\n// }\r\nfunction PsdSphere(){\r\n    this.id = \"sdSphere\";\r\n    this.includes = {};\r\n};\r\nPsdSphere.prototype.getVertexCode = function (out_type,out_var,p,s,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=\" + \"length(\"+p+\")-\"+s+\";\\n\";\r\n        return code;\r\n\r\n    }\r\n};\r\nPsdSphere.prototype.getFragmentCode = function (out_type,out_var,p,s,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        //out_type+\" \" +out_var+\"=\" + \"length(\"+p+\")-\"+s+\";\\n\";\r\n        out_type+\" \" +out_var+\"=sdSphere(\"+p+\",\"+s+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\nPsdSphere.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var p = params.p;\r\n    var s = params.s;\r\n \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var, p,s, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var,p,s,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n/*\r\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\r\n{\r\n    float k0 = length(p/r);\r\n    float k1 = length(p/(r*r));\r\n    return k0*(k0-1.0)/k1;\r\n}\r\n*/\r\n\r\nfunction PsdEllipsoid(){\r\n    this.id = \"sdEllipsoid\";\r\n    this.includes = {};\r\n};\r\nPsdEllipsoid.prototype.getVertexCode = function (out_type,out_var,p,r,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        // var code = \r\n        // \"float k0 =length(\"+p+\"/\"+r+\");\\n\" +\r\n        // \"float k1 =length(\"+p+\"/(\"+r+\"*\"+r+\"));\\n\" +\r\n        // out_type+\" \" +out_var+\"=k0*(k0-1.0)/k1;\\n\";\r\n        var code =out_type+\" \" +out_var+\"= sdEllipsoid(\" +p+\",\"+r+ \");\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPsdEllipsoid.prototype.getFragmentCode = function (out_type,out_var,p,r,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code =out_type+\" \" +out_var+\"= sdEllipsoid(\" +p+\",\"+r+ \");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPsdEllipsoid.prototype.getCode = function (params) {\r\n    //console.log(\"params:\",params)\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var p = params.p;\r\n    var r = params.r;\r\n  \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var, p,r, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, p,r,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n/*\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nvec4 opU( vec4 d1, vec4 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}*/\r\nfunction PopU(){\r\n    this.id = \"opU\";\r\n    this.includes = {};\r\n};\r\nPopU.prototype.getVertexCode = function (out_type,out_var,d1,d2,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code =       \r\n        out_type+\" \" +out_var+\"=(\" +d1.x+\"<\" + d2.x +\")?\" +d1+\":\"+d2+\" ;\\n\";\r\n        return code;\r\n    }\r\n};\r\nPopU.prototype.getFragmentCode = function (out_type,out_var,d1,d2,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code =out_type+\" \" +out_var+\"= opU(\" +d1+\",\"+d2+ \");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPopU.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var d1 = params.d1;\r\n    var d2 = params.d2;\r\n     \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var, d1,d2, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, d1,d2,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n/*\r\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\r\n}\r\n*/\r\nfunction PsdStick(){\r\n    this.id = \"sdStick\";\r\n    this.includes = {};\r\n};\r\nPsdStick.prototype.getVertexCode = function (out_type,out_var,p,a,b,r1,r2,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        \"vec3 pa =\"+p+\"-\"+a+\",ba=\"+b+\"-\"+a+\";\\n\" +\r\n        \"float h = clamp(dot(pa,ba)/dot(ba,ba),0,0,1,0);\"+\r\n        out_type+\" \" +out_var+\"=vec2(length(pa-ba*h)-mix(\"+r1+\",\"+r2+\",h*h*(3.0-2.0*h)),h);\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPsdStick.prototype.getFragmentCode = function (out_type,out_var,p,a,b,r1,r2,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=sdStick(\"+p+\",\"+a+\",\"+b+\",\"+r1+\",\"+r2+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPsdStick.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n\r\n    var p = params.p;\r\n    var a = params.a;\r\n    var b = params.b;\r\n    var r1 = params.r1;\r\n    var r2 = params.r2;\r\n     \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var,p, a,b,r1,r2, scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, p, a,b,r1,r2,scope));\r\n    fragment.setIncludesFromMap(this.includes );\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction Psign(){\r\n    this.id = \"sign\";\r\n    this.includes = {};\r\n};\r\nPsign.prototype.getVertexCode = function (out_type,out_var,p,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=sign(\"+p+\");\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPsign.prototype.getFragmentCode = function (out_type,out_var,p,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=sign(\"+p+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPsign.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var p = params.p;\r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var,p,scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, p,scope));\r\n    fragment.setIncludesFromMap(this.includes);\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction PMat2(){\r\n    this.id = \"mat2\";\r\n    this.includes = {};\r\n};\r\nPMat2.prototype.getVertexCode = function (out_type,out_var,r1,r2,r3,r4,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=mat2(\"+r1 +\",\"+r2+\",\"+r3+\",\"+r4+\");\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPMat2.prototype.getFragmentCode = function (out_type,out_var,r1,r2,r3,r4,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=mat2(\"+r1 +\",\"+r2+\",\"+r3+\",\"+r4+\");\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPMat2.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var r1 = params.r1;\r\n    var r2 = params.r2;\r\n    var r3 = params.r3;\r\n    var r4 = params.r4;\r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var,r1,r2,r3,r4,scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var, r1,r2,r3,r4,scope));\r\n    fragment.setIncludesFromMap(this.includes);\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n\r\n\r\nfunction PPos(){\r\n    this.id = \"pos\";\r\n    this.includes = {};\r\n};\r\nPPos.prototype.getVertexCode = function (out_type,out_var,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=pos;\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPPos.prototype.getFragmentCode = function (out_type,out_var,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=pos;\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPPos.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type, out_var,scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type, out_var,scope));\r\n    fragment.setIncludesFromMap(this.includes);\r\n    return new ShaderCode(vertex, fragment, out_var);\r\n};\r\n\r\n\r\n\r\n\r\nfunction PAtime(){\r\n    this.id = \"atime\";\r\n    this.includes = {};\r\n};\r\nPAtime.prototype.getVertexCode = function (out_type,out_var,scope){\r\n    if(scope == CodePiece.VERTEX || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=aTime;\\n\";\r\n        return code;\r\n \r\n    }\r\n};\r\nPAtime.prototype.getFragmentCode = function (out_type,out_var,scope){\r\n    if(scope == CodePiece.FRAGMENT || scope == CodePiece.BOTH){\r\n        var code = \r\n        out_type+\" \" +out_var+\"=aTime;\\n\";\r\n        return code;\r\n    }\r\n};\r\n\r\nPAtime.prototype.getCode = function (params) {\r\n    var out_var = params.out_var;\r\n    var out_type = params.out_type;\r\n \r\n    var scope = params.scope;\r\n    var order = params.hasOwnProperty(\"order\") ? params.order : Number.MAX_VALUE;\r\n\r\n    var vertex = new CodePiece(order);\r\n    vertex.setBody(this.getVertexCode(out_type,out_var,scope));\r\n    vertex.setIncludesFromMap(this.includes);\r\n    var fragment = new CodePiece(order);\r\n    fragment.setBody(this.getFragmentCode(out_type,out_var,scope));\r\n    fragment.setIncludesFromMap(this.includes);\r\n    return new ShaderCode(vertex,fragment,out_var);\r\n};\r\n\n\n//# sourceURL=webpack:///./js/external/graphAndNode.js?");

/***/ }),

/***/ "./js/external/nodeSubGraph.js":
/*!*************************************!*\
  !*** ./js/external/nodeSubGraph.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nwindow.nodeSubGraph = function(selected_nodes, graph) {\r\n\r\n    this._ctor(selected_nodes, graph)\r\n\r\n}\r\nnodeSubGraph.prototype._ctor = function (selected_nodes, graph) {\r\n    //deep copy selected_nodes\r\n    this.nodes = jQuery.extend(true, {}, selected_nodes);\r\n    this.boundary = 20\r\n    this.properties = { name: \"unnamed\" };\r\n\r\n    this.title_width = LiteGraph.NODE_MIN_WIDTH;\r\n    //size calculate\r\n    //this.size = [LiteGraph.NODE_WIDTH,60];\r\n    this.rect = this.calculateSize()\r\n\r\n    this.graph = graph;\r\n    this.pos = this.rect.pos\r\n    this.size = this.rect.size\r\n    this.id = -1; //not know till not added\r\n    this.type = \"subGraph\"\r\n    this.flags = {\r\n        //skip_title_render: true,\r\n        //unsafe_execution: false,\r\n    };\r\n    //calculate hash\r\n    //1.nodeName order by string\r\n    //2.[input(attribute +\"_\"+ nodeName) --output(attribute +\"_\"+ nodeName] order by string\r\n    //create hashCode\r\n    //console.log(this.nodes)\r\n    var node_names = Object.values(this.nodes).map(a => a.title);\r\n    var node_IDs = Object.values(this.nodes).map(a => a.id);\r\n    var node_inputs_2grad = Object.values(this.nodes).map(a => a.inputs);\r\n     \r\n    this.properties[\"hash\"] =\"\"\r\n    for (var node_inputs_id in node_inputs_2grad) {\r\n        var node_inputs = node_inputs_2grad[node_inputs_id]\r\n        if (node_inputs) {\r\n\r\n            var links = node_inputs.map(a => a.link)\r\n            for (var linkID of links)\r\n                if (linkID) {\r\n\r\n                    var originId = graph.links[linkID].origin_id\r\n                    var originSlot = graph.links[linkID].origin_slot\r\n                    var targetId = graph.links[linkID].target_id\r\n                    var targetSlot = graph.links[linkID].target_slot\r\n\r\n\r\n                    if (node_IDs.indexOf(originId) != -1) {\r\n                        var string = \"|\" + node_names[node_IDs.indexOf(originId)]\r\n                        string += \"_\" + originSlot + \":\"\r\n                        string += node_names[node_IDs.indexOf(targetId)]\r\n                        string += \"_\" + targetSlot\r\n                        \r\n                        node_names[node_IDs.indexOf(targetId)] += string\r\n                    }\r\n\r\n                }\r\n              \r\n       \r\n        }\r\n\r\n       \r\n        \r\n\r\n    }\r\n    //console.log(\"nodeNames before:\", node_names)\r\n    node_names.sort()\r\n    for(var name of node_names)\r\n    this.properties[\"hash\"] += name +\";\"\r\n    \r\n   // console.log(\"nodeNames:\", node_names)\r\n   // console.log(\"nodeIDs:\", node_IDs)\r\n     \r\n}\r\n\r\nnodeSubGraph.prototype.calculateSize = function () {\r\n    var nodePosListX = []\r\n    var nodeSizeListX = []\r\n    var nodePosListY = []\r\n    var nodeSizeListY = []\r\n    for (var node of Object.values(this.nodes)) {\r\n        nodePosListX.push(node.pos[0])\r\n        nodePosListY.push(node.pos[1])\r\n        nodeSizeListX.push(node.pos[0] + node.size[0])\r\n        nodeSizeListY.push(node.pos[1] + node.size[1])\r\n    }\r\n    nodePosListX.sort(function compare(a, b) { return a - b; })\r\n    nodePosListY.sort(function compare(a, b) { return a - b; })\r\n    nodeSizeListX.sort(function compare(a, b) { return b - a; })\r\n    nodeSizeListY.sort(function compare(a, b) { return b - a; })\r\n\r\n    //last smallist\r\n    return {\r\n        \"pos\": [\r\n            nodePosListX[0] - this.boundary,\r\n            nodePosListY[0] - this.boundary\r\n        ],\r\n        \"size\": [\r\n            nodeSizeListX[0] - nodePosListX[0] + this.boundary * 2,\r\n            nodeSizeListY[0] - nodePosListY[0] + this.boundary * 2\r\n        ]\r\n    }\r\n\r\n}\r\nnodeSubGraph.prototype.serialize = function () {\r\n    var nodes_info = [];\r\n    for (var i in this.nodes)\r\n        nodes_info.push(this.nodes[i].serialize());\r\n    console.log(\"nodes saved:\", this.nodes)\r\n    //remove data from links, we dont want to store it\r\n    // for (var i in this.links)\r\n    //     this.links[i].data = null;\r\n\r\n\r\n    var data = {\r\n        //\t\tgraph: this.graph,\r\n        // shader_textures: this.shader_textures,\r\n\r\n        // //shader_output: this.shader_output, this creates a cycle\r\n\r\n        // iteration: this.iteration,\r\n        // frame: this.frame,\r\n        // last_node_id: this.last_node_id,\r\n        // last_link_id: this.last_link_id,\r\n        // links: LiteGraph.cloneObject( this.links ),\r\n\r\n        // config: this.config,\r\n        type: \"subGraph\",\r\n        title: this.title,\r\n        nodes: nodes_info,\r\n        name: this.properties.name\r\n    };\r\n\r\n    return data;\r\n}\r\n\r\n//nodeList\r\n//function 1.move link \r\n//function 4.resize when child move\r\n//function 5.define name in propertiy column\r\n//function 2.save as json\r\n//function 3.init: load all grp json to column\r\n//function 6.drag from colunm\r\n\n\n//# sourceURL=webpack:///./js/external/nodeSubGraph.js?");

/***/ }),

/***/ "./js/subgraph.js":
/*!************************!*\
  !*** ./js/subgraph.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nsubgraph =  {\r\n gcanvas : null,\r\n graph : null,\r\n graph_gl : null,\r\n\r\n\r\ninit:function(){\r\n\r\nthis.graph = new LGraph();\r\n//module.changeGraph(this.graph);\r\n},\r\n\r\n\r\nchangeCanvas:function(){\r\n   \r\n    var container = $(\"#layout_main_layout_panel_main div.w2ui-panel-content\");\r\n    //$(\"#layout_main_layout_panel_main div.w2ui-panel-content canvas\").remove();\r\n\r\n    var h = container.height();\r\n    var w = container.width();\r\n    \r\n    if (!this.graph_gl) {\r\n        this.graph_gl = GL.create({width: w, height: h - 20, alpha: false});\r\n        this.graph_gl.canvas.id = \"subgraph\";\r\n    }\r\n    if (this.gcanvas)\r\n    this.gcanvas.stopRendering();\r\n\r\n     \r\n        var html = \"<canvas id='SubGraph' class='graph' width='\" + w + \"' height='\" + h + \"'></canvas>\";\r\n        container.append(html);\r\n        this.gcanvas = new LGraphCanvas(document.getElementById(\"SubGraph\"), this.graph);\r\n    \r\n    this.gcanvas.background_image = \"img/grid.png\";\r\n\r\n    this.gcanvas.onClearRect = function () {\r\n    \r\n        gl.clearColor(0.2, 0.2, 0.2, 1);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n         \r\n    }\r\n    //console.log(this.gcanvas)\r\n    this.gcanvas.onNodeSelected = function (node) {\r\n        vik.ui.updateLeftPanel(node);\r\n    }\r\n\r\n    this.gcanvas.onDropFile = function (data, filename, file) {\r\n        var ext = LGraphCanvas.getFileExtension(filename);\r\n        if (ext == \"json\") {\r\n            var obj = JSON.parse(data);\r\n            this.graph.configure(obj);\r\n            main_node.mesh = obj.mesh;\r\n            vik.ui.reset();\r\n        }\r\n    }\r\n   \r\n}\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./js/subgraph.js?");

/***/ }),

/***/ 0:
/*!*********************************************************************************!*\
  !*** multi ./js/external/nodeSubGraph ./js/external/graphAndNode ./js/subgraph ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./js/external/nodeSubGraph */\"./js/external/nodeSubGraph.js\");\n__webpack_require__(/*! ./js/external/graphAndNode */\"./js/external/graphAndNode.js\");\nmodule.exports = __webpack_require__(/*! ./js/subgraph */\"./js/subgraph.js\");\n\n\n//# sourceURL=webpack:///multi_./js/external/nodeSubGraph_./js/external/graphAndNode_./js/subgraph?");

/***/ })

/******/ });